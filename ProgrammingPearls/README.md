# Programming Pearls

Programming Pearls의 번역판 제목을 보면 "생각하는 프로그래밍"인것을 알 수 있다.  
그렇다. 이 디렉토리에서는 생각하는 프로그래밍을 하려면 어떻게 해야 할 지를 자루고 있다.  

## 차례

### 1부. 준비

1. 조개 껍질 깨기
2. 알고리즘
3. 프로그램의 구조를 결정하는 데이터
4. 정확한 프로그램 작성

### 2부. 퍼포먼스

1. 퍼포먼스에 대한 개관
2. 봉투 뒷면에 하는 간단한 계산
3. 알고리즘 디자인 기법
4. 코드 튜닝
5. 메모리 절약

### 3부. 프로덕트 

1. 정렬
2. 표본 선정 문제
3. 탐색
4. 힙(Heaps)
	5. 문자열 처리

### 4부. 부록

1. 알고리즘 카탈로그 
2. 추정 퀴즈
3. 시간과 공간에 대한 비용 모델
4. 코드 튜닝을 위한 규칙
5. 탐색을 위한 C++ 클래스

## 1부 1장

1장에서는 주의 깊은 문제 분석과 직관적인 프로그래밍 기법을 조합하여 문제에 알맞은 우아한 솔루션을 얻을 수 있다는 사실에 대해서 알아본다.  
즉, 이 칼럼은 이 책의 중심 주제를 드러낸다.  


책에서는 처음에 한가지 일화를 소개한다.  

> "디스크 파일을 어떻게 정렬하지?"

사실 이 질문을 했던 프로그래머는 진짜로 정렬을 어떻게 하는지가 궁금했던 것이 아니고,  
자신이 직면한 특수한 문제 상황을 해결하려고 했던 것이다. 즉, 공부를 더 하려고 했던 것이 아니었다.  
이런 저런 일을 거쳐서 다시 대화를 통해 문제를 정확하게 정의하는 상황으로 다시 돌아왔고,  
대화를 통해서 얻어낸 정확한 문제 기술 내용은 다음과 같다.

| 항목     	| 내용                                                                                                                                                             	|
|----------	|------------------------------------------------------------------------------------------------------------------------------------------------------------------	|
| 출력     	| 입력된 정수를 오름차순으로 정렬한 리스트                                                                                                                         	|
| 제약조건 	| 메모리를 많아야 대략 1MB정도를 사용할 수 있고, 디스크 공간은 충분하다. 실행시간은 최대 몇 분 정도가 될 수 있고, 10초 내외로 작업을 끝낼 수 있으면 충분하다.      	|
| 입력     	| 최대 n개의 양의 정수를 포함하는 파일로, 각 숫자는 n보다 작고, n = 10^7이다.어떤 숫자가 두 번이상 나오는 것은 치명적인 에러이다.정수 이외에 관련된 데이터는 없다. 	|

이 문제의 명세(specification)에 대해서 잠시 생각해보라.  
이제 그 프로그래머에게 어떤 조언을 해줄 수 있겠는가?

### 프로그램 디자인

바로 떠오르는 방법은 일반적인디스크 기반의 머지 정렬을 사용하는 것으로,  
정수를 정렬한다는 사실을 이용하여 프로그램을 조금 다듬으면 코드를 줄을 줄일 수 있고  
실행속도도 더 빠르게 할 수 있다. 아마 코드를 작성하고 실행하는 데 며칠 정도 걸릴 것이다.  


두 번째 솔루션은 이 정렬 문제의 특별한 성질을 더 많이 이용하도록 하는 것이다.  
만약 각각의 숫자를 7바이트에 저장한다면 사용 가능한 메모리(1MB)에 에 약 143,000개의 숫자를 저장할 수 있다.  
그러나 각 숫자를 32비트 정수로 표현하면 250,000개의 숫자를 저장할 수 있다.  
따라서 우리는 입력 파일을 40번 읽는 프로그램을 사용할 것이다. 
첫 번째 패스(pass)에서는 0부터 249,999까지의 숫자를 메모리로 읽어들여 25만개의 정수를 정렬한 다음 출력 파일에 저장한다.  
이 과정을 10^7까지 반복한다. 즉, 전부 정렬하려면 40단계를 거치면 된다.  
메모리에서 정렬할 때는 추가적인 메모리를 사용하지 않는 퀵 정렬이 효과적이고, 코드도 길지 않다.  
중간 단계의 디스크 파일을 사용하지 않지만 40단계나 거쳐야 한다는 단점이 있다.  


사실 문제를 좀 더 구체적으로 분석하면 더 좋은 솔루션을 찾을 수 있다.  
머지 정렬과 퀵 정렬을 합친다면 말이다.  



### 구현 스케치

### 원리
